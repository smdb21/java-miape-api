package org.proteored.miapeapi.xml.msi.adapter;

import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;
import org.proteored.miapeapi.interfaces.Adapter;
import org.proteored.miapeapi.interfaces.msi.IdentifiedPeptide;
import org.proteored.miapeapi.xml.msi.autogenerated.MSIIdentifiedPeptide;
import org.proteored.miapeapi.xml.msi.autogenerated.MSIIdentifiedPeptideSet;
import org.proteored.miapeapi.xml.msi.autogenerated.ObjectFactory;
import org.proteored.miapeapi.xml.msi.util.MSIControlVocabularyXmlFactory;

import edu.scripps.yates.utilities.cores.SystemCoreManager;
import edu.scripps.yates.utilities.pi.ParIterator;
import edu.scripps.yates.utilities.pi.ParIteratorFactory;
import edu.scripps.yates.utilities.pi.ParIterator.Schedule;
import edu.scripps.yates.utilities.pi.exceptions.ParIteratorException;
import edu.scripps.yates.utilities.pi.reductions.Reducible;
import edu.scripps.yates.utilities.pi.reductions.Reduction;

public class IdentifiedPeptideSetParallelAdapter implements
		Adapter<MSIIdentifiedPeptideSet> {
	private final List<IdentifiedPeptide> identifiedPeptides;
	private final ObjectFactory factory;
	private final MSIControlVocabularyXmlFactory cvFactory;
	private static Logger log = Logger.getLogger("log4j.logger.org.proteored");

	public IdentifiedPeptideSetParallelAdapter(
			List<IdentifiedPeptide> identifiedPeptides, ObjectFactory factory,
			MSIControlVocabularyXmlFactory cvFactory) {
		this.identifiedPeptides = identifiedPeptides;
		this.factory = factory;
		this.cvFactory = cvFactory;
	}

	@Override
	public MSIIdentifiedPeptideSet adapt() {
		MSIIdentifiedPeptideSet ret = factory.createMSIIdentifiedPeptideSet();

		if (identifiedPeptides != null && !identifiedPeptides.isEmpty()) {

			int threadCount = SystemCoreManager.getAvailableNumSystemCores();
			log.info("Preparing parallel processor of peptides using "
					+ threadCount + " threads");
			final ParIterator<IdentifiedPeptide> iterator = ParIteratorFactory
					.createParIterator(identifiedPeptides, threadCount,
							Schedule.GUIDED);

			Reducible<List<MSIIdentifiedPeptide>> reduciblePeptides = new Reducible<List<MSIIdentifiedPeptide>>();

			List<IdentifiedPeptideParallelProcessor> runners = new ArrayList<IdentifiedPeptideParallelProcessor>();
			for (int numCore = 0; numCore < threadCount; numCore++) {
				// take current DB session
				IdentifiedPeptideParallelProcessor runner = new IdentifiedPeptideParallelProcessor(
						numCore, iterator, reduciblePeptides, factory,
						cvFactory);
				runners.add(runner);
				runner.start();
			}

			// Main thread waits for worker threads to complete
			for (int k = 0; k < threadCount; k++) {
				try {
					runners.get(k).join();
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				}
			}
			final ParIteratorException<IdentifiedPeptide>[] allExceptions = iterator
					.getAllExceptions();
			if (allExceptions.length != 0) {
				throw new IllegalArgumentException(
						allExceptions[0].getException());
			}
			// Reductors
			Reduction<List<MSIIdentifiedPeptide>> peptideListReduction = new Reduction<List<MSIIdentifiedPeptide>>() {
				@Override
				public List<MSIIdentifiedPeptide> reduce(
						List<MSIIdentifiedPeptide> first,
						List<MSIIdentifiedPeptide> second) {
					List<MSIIdentifiedPeptide> peptides = new ArrayList<MSIIdentifiedPeptide>();
					peptides.addAll(first);
					peptides.addAll(second);
					return peptides;
				}
			};
			final List<MSIIdentifiedPeptide> peptides = reduciblePeptides
					.reduce(peptideListReduction);
			ret.getMSIIdentifiedPeptide().addAll(peptides);

		}
		return ret;
	}

}
