package org.proteored.miapeapi.util;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.util.HashMap;

import org.apache.commons.io.FilenameUtils;
import org.apache.log4j.Logger;
import org.proteored.miapeapi.cv.ControlVocabularyManager;
import org.proteored.miapeapi.cv.ms.MSFileType;
import org.proteored.miapeapi.exceptions.IllegalMiapeArgumentException;
import org.proteored.miapeapi.interfaces.ms.ResultingData;
import org.proteored.miapeapi.xml.pride.adapter.SpectrumListAdapter;
import org.proteored.miapeapi.xml.pride.adapter.mzml.MzMLSpectrumIDManager;
import org.proteored.miapeapi.xml.pride.adapter.mzml.SpectrumAdapter;
import org.proteored.miapeapi.xml.pride.adapter.mzml.SpectrumAdapter2;
import org.proteored.miapeapi.xml.pride.autogenerated.ExperimentType.MzData.SpectrumList;
import org.proteored.miapeapi.xml.pride.autogenerated.ExperimentType.MzData.SpectrumList.Spectrum;
import org.proteored.miapeapi.xml.pride.autogenerated.ObjectFactory;
import org.proteored.miapeapi.xml.pride.util.PrideControlVocabularyXmlFactory;
import org.proteored.miapeapi.xml.util.peaklistreader.TMsData;
import org.proteored.miapeapi.xml.util.peaklistreader.TSpectrum;
import org.proteored.miapeapi.zip.ZipManager;

import uk.ac.ebi.jmzml.model.mzml.ReferenceableParamGroupList;
import uk.ac.ebi.jmzml.xml.io.MzMLObjectIterator;
import uk.ac.ebi.jmzml.xml.io.MzMLUnmarshaller;

public class SpectraReader {
	private static Logger log = Logger.getLogger("log4j.logger.org.proteored");
	private static SpectraReader instance;
	private static ObjectFactory factory = new ObjectFactory();
	private static ControlVocabularyManager cvManager;
	private static PrideControlVocabularyXmlFactory prideCvUtil;

	private SpectraReader(ControlVocabularyManager cvManager) {

		SpectraReader.cvManager = cvManager;
		SpectraReader.prideCvUtil = new PrideControlVocabularyXmlFactory(
				factory, cvManager);
	}

	public static SpectraReader getInstance(ControlVocabularyManager cvManager) {
		if (instance != null)
			return instance;
		instance = new SpectraReader(cvManager);
		return instance;
	}

	/**
	 * Parse the MGF file located in the DataFileUri of the resultingData
	 * 
	 * @param resultingData
	 * @param mgfTitlesMaps
	 * 
	 * @return the {@link TMsData} containing spectra
	 * 
	 *         throws {@link IllegalMiapeArgumentException} if the file have not
	 *         been parsed correctly
	 */
	public TMsData getSpectraFromMGFs(ResultingData resultingData,
			HashMap<String, Integer> mgfTitlesMaps) {
		TMsData tMsData;
		if (resultingData == null)
			throw new IllegalMiapeArgumentException(
					"Resulting data is null. No MGF file available");
		String mgfFileURL = parseURL(resultingData, "mgf");
		log.info("Parsing MGF " + mgfFileURL);
		try {
			tMsData = new TMsData(mgfFileURL, mgfTitlesMaps);
		} catch (Exception e) {
			e.printStackTrace();
			log.info("Error: " + e.getMessage());
			throw new IllegalMiapeArgumentException("Error reading mgf file: "
					+ mgfFileURL + " -> " + e.getMessage());
		}
		HashMap<Integer, TSpectrum> spectra = tMsData.getSpectra();
		if (spectra == null || spectra.isEmpty()) {
			try {
				// algunos están comprimidos dos veces, por lo que si no salen
				// espectros, probar a descomprimir otra vez!

				File decompressGZipFile = ZipManager
						.decompressGZipFile(new File(new URL(mgfFileURL)
								.toURI()));
				tMsData = new TMsData(decompressGZipFile.toURL().toString(),
						mgfTitlesMaps);

				spectra = tMsData.getSpectra();
				if (spectra == null || spectra.isEmpty()) {
					throw new IllegalMiapeArgumentException(
							"No spectra readed from mgf file: " + mgfFileURL);
				}
			} catch (Exception e) {
				log.info("Error");
				log.info(e.getMessage());
				throw new IllegalMiapeArgumentException(
						"Error reading mgf file: " + mgfFileURL);

			}

		}

		log.info(spectra.size() + " spectra readed");

		return tMsData;
	}

	public int addSpectraFromMzML(SpectrumList spectrumList,
			ResultingData resultingData, int offset,
			MzMLSpectrumIDManager spectrumIDManager, int miapeMSid) {
		if (resultingData == null)
			throw new IllegalMiapeArgumentException(
					"Resulting data is null. No mzML file available");
		String mzMLFileURL = parseURL(resultingData, "mzML");
		int numSpectra = 0;
		// Parse mzML file
		try {
			long initTime = System.currentTimeMillis();

			MzMLUnmarshaller mzMLUnmarshaller = new MzMLUnmarshaller(new URL(
					mzMLFileURL));
			long finishTime = System.currentTimeMillis();
			log.info("Index created in " + (finishTime - initTime) / 1000
					+ " seconds");
			MzMLObjectIterator<uk.ac.ebi.jmzml.model.mzml.Spectrum> spectrumIterator = mzMLUnmarshaller
					.unmarshalCollectionFromXpath("/run/spectrumList/spectrum",
							uk.ac.ebi.jmzml.model.mzml.Spectrum.class);
			if (spectrumIterator == null)
				throw new IllegalMiapeArgumentException(
						"Spectrum iterator for mzML " + mzMLFileURL
								+ " is null");
			ReferenceableParamGroupList referenceableParamGroupList = mzMLUnmarshaller
					.unmarshalFromXpath("/referenceableParamGroupList",
							ReferenceableParamGroupList.class);
			final int totalSpectra = mzMLUnmarshaller
					.getObjectCountForXpath("/run/spectrumList/spectrum");

			while (spectrumIterator.hasNext()) {
				Thread.sleep(1L);

				// read next spectrum from XML file
				uk.ac.ebi.jmzml.model.mzml.Spectrum mzMLspectrum = spectrumIterator
						.next();
				// add the mapping between the spectrum Identifier and the index
				// of the spectrum
				spectrumIDManager.addNewSpectrumMapping(miapeMSid
						+ mzMLspectrum.getId(), numSpectra + 1 + offset);
				Spectrum prideXmlSpectrum = null;
				try {
					// create the PRIDE XML spectrum object
					prideXmlSpectrum = new SpectrumAdapter2(mzMLUnmarshaller,
							mzMLspectrum, referenceableParamGroupList, factory,
							prideCvUtil, spectrumIDManager, miapeMSid).adapt();
				} catch (IllegalMiapeArgumentException e) {
					log.warn(e.getMessage());
					continue;
				}

				// Add to the spectrumMap
				SpectrumListAdapter.getSpectrumMap().put(
						BigInteger.valueOf(prideXmlSpectrum.getId()),
						prideXmlSpectrum);

				spectrumList.getSpectrum().add(prideXmlSpectrum);
				// log.info(mzMLspectrum.getId() + " - " +
				// prideXmlSpectrum.getId());

				numSpectra++;
				if ((Double.valueOf(numSpectra) / Double.valueOf(totalSpectra)) % 10 == 0)
					log.info((numSpectra * 100) / totalSpectra
							+ "% spectra processed");
			}
			spectrumList.setCount(numSpectra);
		} catch (Exception e) {
			log.info("Error");
			log.info(e.getMessage());
			throw new IllegalMiapeArgumentException(e.getMessage());
		}

		return numSpectra;
	}

	private static String parseURL(ResultingData resultingData, String extension) {
		String fileURL = resultingData.getDataFileUri();
		// Receive file
		log.info("Receiving " + extension + " " + fileURL + " file");
		try {
			File file = SpectraReader.receiveFile(fileURL);

			// fileURL = mgfFile.getAbsolutePath();
			fileURL = file.toURI().toURL().toString();
		} catch (IOException ex) {
			log.info("IOException when receiving" + extension + " file:"
					+ ex.getMessage());
			fileURL = resultingData.getDataFileUri();
		}

		log.info("Reading " + extension + " file from the URL: " + fileURL);
		// check if the URL is OK
		try {
			new URL(fileURL);
		} catch (MalformedURLException ex) {
			log.info("MalformedURLException when trying to create an URL from "
					+ fileURL);
			fileURL = "file:/" + fileURL;
			log.info("Now trying with " + fileURL);
		}
		return fileURL;
	}

	private static File receiveFile(String fileName) throws IOException {

		URL url;
		// check if the fileName is already an URL
		try {
			url = new URL(URLParamEncoder.encode(fileName));

		} catch (Exception ex) {
			log.info("The filename: " + fileName
					+ " is not an URL. Trying to get from a File object");
			url = new File(fileName).toURI().toURL();
		}
		if (url != null && url.getProtocol() != null
				&& url.getProtocol().equals("file")) {
			File ret = new File(URLDecoder.decode(url.getFile(), "UTF-8"));
			if (ret.exists())
				return ret;

		}
		File outPutFile = File.createTempFile("temp",
				"." + FilenameUtils.getExtension(fileName));
		log.info("Output file: " + outPutFile.getAbsolutePath());

		BufferedOutputStream os = new BufferedOutputStream(
				new FileOutputStream(outPutFile));

		log.info("Retrieving File: " + url.toString());
		URLConnection uc = url.openConnection();
		uc.setRequestProperty("User-Agent", "Mozilla/5.0 ( compatible ) ");
		uc.setRequestProperty("Accept", "[star]/[star]");

		// String contentType = uc.getContentType();
		// int contentLength = uc.getContentLength();
		// if (contentType!=null && contentType.startsWith("text/") ||
		// contentLength == -1) {
		// // throw new IOException("This is not a binary file.");
		// }

		InputStream inputStream = uc.getInputStream();
		BufferedInputStream is = new BufferedInputStream(inputStream);
		ZipManager.copyInputStream(is, os);

		log.info("Finished Retrieving File (" + outPutFile.length() / 1024
				/ 1024 + " Mb): " + outPutFile.getAbsolutePath());

		outPutFile = ZipManager
				.decompressGZipFileIfNeccessary(outPutFile, true);
		return outPutFile;
	}

	/**
	 * Search for a resulting data with a dataFileURI not empty and a
	 * dataFileType=MASCOT_MGF
	 * 
	 * @param resultingData
	 * @return
	 */
	private boolean hasMGFFile(ResultingData resultingData) {
		final String dataFileUri = resultingData.getDataFileUri();
		if (dataFileUri != null && !"".equals(dataFileUri)) {
			final String dataFileType = resultingData.getDataFileType();
			final String mascotMGFPReferredName = MSFileType
					.getInstance(cvManager)
					.getCVTermByAccession(MSFileType.MASCOT_MGF)
					.getPreferredName();
			if (dataFileType.equals(mascotMGFPReferredName)
					|| dataFileType.contains("MGF"))
				return true;
		}
		return false;
	}

	/**
	 * Search for a resulting data with a dataFileURI not empty and a
	 * dataFileType=MzML
	 * 
	 * @param resultingData
	 * @return
	 */
	private boolean hasMzMLFile(ResultingData resultingData) {
		final String dataFileUri = resultingData.getDataFileUri();
		if (dataFileUri != null && !"".equals(dataFileUri)) {
			final String dataFileType = resultingData.getDataFileType();
			if (dataFileType.equals(MSFileType.getInstance(cvManager)
					.getCVTermByAccession(MSFileType.MZML_ACC)
					.getPreferredName()))
				return true;
		}
		return false;
	}

	public static void main(String[] args) {
		String urlToFile = "http://proteo.cnb.csic.es/downloads/sgharbi@cnb.csic.es/HPP CHAPS FR1.mgf.gz";
		TMsData tMsData = null;
		String fileURLString = null;
		try {
			File fileReceived = receiveFile(urlToFile);
			fileURLString = fileReceived.toURI().toURL().toString();
			tMsData = new TMsData(fileURLString, null);
			if (!tMsData.getSpectra().isEmpty())
				System.out.println("OLE");
			else {
				File decompressGZipFile;
				try {
					decompressGZipFile = ZipManager
							.decompressGZipFile(new File(new URL(fileURLString)
									.toURI()));
					tMsData = new TMsData(
							decompressGZipFile.toURL().toString(), null);
					if (!tMsData.getSpectra().isEmpty())
						System.out.println("OLE");
				} catch (FileNotFoundException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (MalformedURLException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (URISyntaxException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		} catch (Exception e) {

		}
	}

	/**
	 * Gets the {@link Spectrum} from a file in a {@link ResultingData}
	 * 
	 * @param spectrumRef
	 * @param resultingData
	 * 
	 * @return
	 */
	public Spectrum getSpectraFromResultingData(int spectrumRef,
			ResultingData resultingData) {
		try {
			if (resultingData != null) {
				if (hasMGFFile(resultingData)) {
					final String localFilePath = parseURL(resultingData, "mgf");
					Spectrum spectrum = getSpectrumFromMGF(spectrumRef,
							localFilePath);
					return spectrum;
				} else if (hasMzMLFile(resultingData)) {
					final String localFilePath = parseURL(resultingData, "mzML");
					Spectrum spectrum = getSpectrumFromMzML(spectrumRef,
							localFilePath);
					return spectrum;
				} else {
					return null;
				}

			}
		} catch (IllegalMiapeArgumentException e) {
			log.info(e.getMessage());
		}

		return null;
	}

	private Spectrum getSpectrumFromMzML(int spectrumRef, String mzMLFileURI) {
		try {
			long initTime = System.currentTimeMillis();

			MzMLUnmarshaller mzMLUnmarshaller = new MzMLUnmarshaller(new URL(
					mzMLFileURI));
			long finishTime = System.currentTimeMillis();
			log.info("Index created in " + (finishTime - initTime) / 1000
					+ " seconds");

			ReferenceableParamGroupList referenceableParamGroupList = mzMLUnmarshaller
					.unmarshalFromXpath("/referenceableParamGroupList",
							ReferenceableParamGroupList.class);

			final String spectrumIDFromSpectrumIndex = mzMLUnmarshaller
					.getSpectrumIDFromSpectrumIndex(spectrumRef);
			final uk.ac.ebi.jmzml.model.mzml.Spectrum spectrumById = mzMLUnmarshaller
					.getSpectrumById(spectrumIDFromSpectrumIndex);
			Spectrum prideXmlSpectrum = new SpectrumAdapter(mzMLUnmarshaller,
					spectrumById, referenceableParamGroupList, factory,
					prideCvUtil, 0, null).adapt();
			if (prideXmlSpectrum != null) {
				log.info("spectrum found in mzML file " + mzMLFileURI);
				return prideXmlSpectrum;
			}

			MzMLObjectIterator<uk.ac.ebi.jmzml.model.mzml.Spectrum> spectrumIterator = mzMLUnmarshaller
					.unmarshalCollectionFromXpath("/run/spectrumList/spectrum",
							uk.ac.ebi.jmzml.model.mzml.Spectrum.class);
			if (spectrumIterator == null)
				throw new IllegalMiapeArgumentException(
						"Spectrum iterator for mzML " + mzMLFileURI
								+ " is null");

			while (spectrumIterator.hasNext()) {
				// read next spectrum from XML file
				uk.ac.ebi.jmzml.model.mzml.Spectrum mzMLspectrum = spectrumIterator
						.next();
				if (mzMLspectrum.getIndex() == spectrumRef) {
					prideXmlSpectrum = new SpectrumAdapter(mzMLUnmarshaller,
							mzMLspectrum, referenceableParamGroupList, factory,
							prideCvUtil, 0, null).adapt();
					log.info("spectrum found in mzML file " + mzMLFileURI);
					return prideXmlSpectrum;
				}
			}

		} catch (Exception e) {
			log.info("Error");
			log.info(e.getMessage());
			throw new IllegalMiapeArgumentException(e.getMessage());
		}
		return null;

	}

	private Spectrum getSpectrumFromMGF(int spectrumRef, String mgfFileURI) {
		TMsData tMsData;
		try {
			tMsData = new TMsData(mgfFileURI, null);
		} catch (Exception e) {
			log.info("Error");
			log.info(e.getMessage());
			throw new IllegalMiapeArgumentException("Error reading mgf file: "
					+ spectrumRef);
		}
		HashMap<Integer, TSpectrum> spectra = tMsData.getSpectra();
		if (spectra == null || spectra.isEmpty()) {
			try {
				// algunos están comprimidos dos veces, por lo que si no salen
				// espectros, probar a descomprimir otra vez!

				File decompressGZipFile = ZipManager
						.decompressGZipFile(new File(new URL(mgfFileURI)
								.toURI()));
				tMsData = new TMsData(decompressGZipFile.toURL().toString(),
						null);

				spectra = tMsData.getSpectra();
				if (spectra == null || spectra.isEmpty()) {
					throw new IllegalMiapeArgumentException(
							"No spectra readed from mgf file: " + mgfFileURI);
				}
			} catch (Exception e) {
				log.info("Error");
				log.info(e.getMessage());
				throw new IllegalMiapeArgumentException(
						"Error reading mgf file: " + mgfFileURI);

			}

		}

		log.info(spectra.size() + " spectra readed");
		try {
			Spectrum spectrum = new SpectumAdapterFromMGFSpectrum(tMsData,
					spectrumRef, 0, SpectraReader.factory,
					SpectraReader.cvManager).adapt();
			return spectrum;
		} catch (IllegalMiapeArgumentException e) {
			log.warn(e.getMessage());
			return null;
		}

	}
}
